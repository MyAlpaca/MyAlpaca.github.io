<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构</title>
      <link href="2021/05211106.html"/>
      <url>2021/05211106.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据结构和算法"><a href="#一、数据结构和算法" class="headerlink" title="一、数据结构和算法"></a>一、数据结构和算法</h1><h2 id="1-数据结构在学什么"><a href="#1-数据结构在学什么" class="headerlink" title="1.数据结构在学什么"></a>1.数据结构在学什么</h2><h2 id="2-数据结构的基本概念"><a href="#2-数据结构的基本概念" class="headerlink" title="2.数据结构的基本概念"></a>2.数据结构的基本概念</h2><h2 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h2><h2 id="4-算法的时间复杂度"><a href="#4-算法的时间复杂度" class="headerlink" title="4.算法的时间复杂度"></a>4.算法的时间复杂度</h2><h2 id="5-算法的空间复杂度"><a href="#5-算法的空间复杂度" class="headerlink" title="5.算法的空间复杂度"></a>5.算法的空间复杂度</h2><h1 id="二、线性表"><a href="#二、线性表" class="headerlink" title="二、线性表"></a>二、线性表</h1><h2 id="1-线性表的定义和基本操作-采用顺序表"><a href="#1-线性表的定义和基本操作-采用顺序表" class="headerlink" title="1.线性表的定义和基本操作(采用顺序表)"></a>1.线性表的定义和基本操作(采用顺序表)</h2><h3 id="（1）顺序表的定义"><a href="#（1）顺序表的定义" class="headerlink" title="（1）顺序表的定义"></a>（1）顺序表的定义</h3><pre class=" language-c++"><code class="language-c++">#define MaxSize 10 //定义最大长度typedef struct{    int data[MaxSize];//用静态的“数组”存放数据元素    int length;//顺序表的当前长度}SqList;</code></pre><h3 id="（2）顺序表的插入删除"><a href="#（2）顺序表的插入删除" class="headerlink" title="（2）顺序表的插入删除"></a>（2）顺序表的插入删除</h3><blockquote><p>==插入==</p></blockquote><p>ListInsert(&amp;L,i,e): 插入操作。在表L中的第i个位置上插入指定元素e</p><p><strong>注：这里的i从1开始，表示要插入到表中的位序，i的范围为[1,length+1]</strong></p><pre class=" language-c++"><code class="language-c++">bool ListInsert(SqList &L,int i,int e){    /*    元素要插入的位置不是大于第一个，或者大于表的长度+1，则不能插入。L.length+1表示尾插，可以在L.length+1的位置插入元素    */    if(i<1||i>L.length+1){        return false;    }    //表已满    if(L.length>=MaxSize){        return false;    }    /*    若要将e插入到第i个位置，首先将最后一个元素向后移动一位。前面元素依次类推，直到移动到第i个元素结束。用以下这种方式，循环结束后，j和i-1的值相等    */    for(int j = L.length;j>=i;j--){        L.data[j] = L.data[j-1];    }    //这里i对应的数组元素下标为i-1，数组下标从0开始，i从1开始    L.data[i-1] = e;    L.length++;    return true;}</code></pre><p><strong>时间复杂度：</strong> </p><p>问题规模n=L.length(表长)</p><ul><li><p>最好情况：新元素插入到表尾，不需要移动，最好时间复杂度为O(1)</p></li><li><p>最坏情况：新元素插入到表头，需要将原有的n个元素全都向后移动,最坏时间复杂度为O(n)</p></li><li><p>平均情况：假设新元素插入到任意位置的概率相同，即p=1/(n+1)。总循环次数为一个等差数列之和，即s=[n(n+1)]/2。平均循环次数为sp=n/2。即平均时间复杂度为O(n)。</p></li></ul><blockquote><p>==删除==</p></blockquote><p>ListDelete(&amp;L,i,&amp;e):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值</p><pre class=" language-c++"><code class="language-c++">bool ListDelete(SqList &L,int i,int &e){    //这里为L.length,是最后一个元素的位序（不是下标）    if(i<1||i>L.length){        return false;    }    //先将要删除的元素保存到e中    e=L.data[i-1];    //从i后面一个元素开始，依次往前移动    for(int j = i;j<L.length;j++){        L.data[j-1] = L.data[j];    }    //移动完，长度减1    L.length--;    return true;}</code></pre><p><strong>时间复杂度：</strong> </p><p>问题规模n=L.length(表长)</p><ul><li>最好情况：删除表尾元素，不需要移动，最好时间复杂度为O(1)</li><li>最坏情况：删除表头元素，需要将后续的n-1个元素全都向前移动,最坏时间复杂度为O(n)</li><li>平均情况：假设删除任意元素的概率相同，即p=1/n。总循环次数为一个等差数列之和，即s=[n(n-1)]/2。平均循环次数为sp=(n-1)/2。即平均时间复杂度为O(n)。</li></ul><h3 id="（3）顺序表的查找"><a href="#（3）顺序表的查找" class="headerlink" title="（3）顺序表的查找"></a>（3）顺序表的查找</h3><blockquote><p>==按位查找==</p></blockquote><p>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素。</p><pre class=" language-c++"><code class="language-c++">int GetElem(SqList L,int i){    //这里为L.length,是最后一个元素的位序（不是下标）    if(i<1||i>L.length){        return;    }    return L.data[i-1];}</code></pre><p><strong>时间复杂度</strong></p><p>由于顺序表为随机存取，显示，时间复杂度为O(1)。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
